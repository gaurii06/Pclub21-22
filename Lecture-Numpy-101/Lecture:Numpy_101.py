# -*- coding: utf-8 -*-
"""Lecture : Numpy 101

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SCE_wBIUQrfK4BI5PIJqVZrZAXeMjqBC

This tutorial was contributed by [Ashwani Rathee](https://github.com/ashwani-rathee) and [Abhiroop Singh](https://github.com/abhiroopsk)
"""

!python --version

"""### What is NumPy?

NumPy, which stands for Numerical Python, is a python library consisting of multidimensional array objects and a collection of routines for processing those arrays. Using NumPy, mathematical and logical operations on arrays can be performed. This tutorial explains the basics of NumPy such as its architecture and environment. It also discusses the various array functions, types of indexing, etc.

In 2005,Travis Oliphant created NumPy Package based on previous NumArray.NumPy is often used along with packages like Pandas,SciPy (Scientific Python) and Mat−plotlib (plotting library). 

###Why use NumPy?
In Python we have lists that serve the purpose of arrays, but they are slow to process.

NumPy aims to provide an array object that is up to 50x faster than traditional Python lists.

The array object in NumPy is called "ndarray", it provides a lot of supporting functions that make working with ndarray very easy.

Arrays are very frequently used in data science, where speed and resources are very important.
<img src="https://i.imgur.com/jKHfhRB.png" alt="alt text" width="500"/>


### Audience :
- People who wish to learn about machine learning concepts in future.

#### Prerequisites :
- Basic Understanding of computer programming technologies

#### Method to install : 
If you have Python and PIP already installed on a system, then install it using this command:
```
pip install numpy
```

### Import Numpy 
<img src="https://i.imgur.com/Uv7ktFX.png" alt="alt text" width="200"/>
"""

import numpy as np 
import matplotlib.pylab as plt
from numpy import random
#np is a common alias for numpy
print("Numpy Version: " ,np.__version__,)

#np? #Help function

"""###Example

A numpy array is a grid of values, all of the same type, and is indexed by a tuple of nonnegative integers. The number of dimensions is the rank of the array; the shape of an array is a tuple of integers giving the size of the array along each dimension.

To create an ndarray, we can pass a list, tuple or any array-like object into the array() method, and it will be converted into an ndarray:
"""

sample_list=[1,2,3,4,5]
arr = np.array(sample_list,dtype=np.int8) #we can specify the datatype,creates array of rank 1
print(arr)
print(type(arr))

"""### Array Creation

#### 0-D Arrays
0-D arrays, or Scalars, are the elements in an array. Each value in an array is a 0-D array.
"""

arr = np.array(42)
print(arr)

"""#### 1-D Arrays
*An* array that has 0-D arrays as its elements is called uni-dimensional or 1-D array.
"""

arr = np.array([1, 2, 3, 4, 5])
print(arr)

"""#### 2-D Arrays
An array that has 1-D arrays as its elements is called a 2-D array.
"""

arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr)

"""#### 3-D arrays
An array that has 2-D arrays (matrices) as its elements is called 3-D array.
"""

arr = np.array([[[1, 2, 3], [4, 5, 6]], [[1, 2, 3], [4, 5, 6]]])
print(arr)

a = np.array([1,2,3]) 
b = np.array([[1, 2], [3, 4]]) 
c = np.array([1, 2, 3], dtype = complex) 
print("A : \n",a)
print("B : \n",b)
print("C : \n",c)

"""#### Generate Random Array:"""

x1 = np.random.randint(10, size=6)  # One-dimensional array
x2 = np.random.randint(10, size=(3, 4))  # Two-dimensional array
x3 = np.random.randint(10, size=(3, 4, 5))  # Three-dimensional array
np.random.randint(10,50,5) #start,stop,no of values

# print(x1);
print("x2: \n", x2);
# Try to print x3 array
# print(...);

"""#### Other methods: Using Arange,Linspace,Zeros,Ones"""

np.arange(0,10,2) #start,stop,size of step

np.linspace(0,10,5) #start,stop,number of values in between

np.zeros(3)

np.ones((3,2))

"""### Ndarray Properties"""

print("x2 ndim: ", x2.ndim) # ndim-> the number of dimensions
print("x2 shape:", x2.shape) # shape-> the size of each dimension
print("x2 size: ", x2.size) # size-> the total size of the array
print("x2 datatype: ", x2.dtype) # dtype-> the data type of the array
print("x2 itemsize: ", x2.itemsize,"bytes") # itemsize-> lists size of each array element
print("x2 nbytes: ", x2.nbytes,"bytes") # nbytes->  lists the total size (in bytes) of the array

List = [0,'lecture',1.0,5.6234]
# List.dtype
data = np.array(List)
data.dtype

"""### Array indexing

"""

#Array indexing
# If we want to access element in different dimensions arrays
# In single dimensional x1 array :  
print(x1)
print("Array 1:",x1[1]);
# In 2-dimensional x2 array :
# print(x2[i,j]);
print(x2)
print("Array 2:",x2[1,1])
# In 3-dimensional x3 array :
print("Array 3:",x3[1,1,1]);

"""### Array Slicing
Slicing in python means taking elements from one given index to another given index.
A slice of an array is a view into the same data, so modifying it will modify the original array.
"""

x1 = np.arange(10)
print("Example 1:",x1[0:10]) # x1[start:end]
print("Example 2:",x1[0:10:2]) # x1[start:end:step]
print("Example 3:",x1[0:]) # all elements from index 0 to the end of the array
print("Example 4:",x1[:5]) # all elements from beginning to index 5
#Negative slicing can also be done
print("Example 5:",x1[::2]) #return every other element from start index 0 to index 10

x2 = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

print("Example 6:",x2[0:2, 1:4]) #  slice index 1 to index 4 (not included),2-d array returned

"""### Array Manipulation"""

x1 = np.arange(10)
print("x1:",x1)
x1[0] = 5
print("x1:",x1)

print("x2:\n",x2)
print("Logical operation in arrays:",x2[(x2>3) & (x2<7)])
print("Example 2:",x2[x2>5])

new_arr= np.array([0,1,2,1,3,4,1])
print("Print Unique Array:",np.unique(new_arr)) # using np.unique method

print("Array x2 :\n",x2)
print("Array x2':\n",np.transpose(x2)) #Transpose of array

print("Array x2 :\n",x2)
print("Array x2':\n",x2.flatten()) # Flatten the array

x2 = np.random.randint(10, size=(3, 4))
print(x2)
print("Sorted Array x2:\n",x2.sort(axis=1)) 
x2.sort(axis=1) #issues coming here

"""### Array Reshaping

"""

arr = np.arange(10)
print("Initial Array : ",arr)
print("Initial Array Shape: ",arr.shape)
arr = arr.reshape(2,5)
print("Final Array  : \n",arr)
print("Final Array Shape: ",arr.shape)

"""### Array Resizing
- Using Shape
- Using Resize
"""

# Using Shape
arr = np.array([[1,2,3],[4,5,6]]) 
print(arr.shape) #initially it had two rows and three columns
arr.shape = (3,2) 
print(arr) #Now,It has three rows and two columns

# Using Resize
arr = np.array([[1,2,3],[4,5,6]]) 
print(arr.shape) #initially it had two rows and three columns
arr = arr.reshape(3,2) 
print(arr) #Now,It has three rows and two columns

# Do it yourself
brr = np.array([[1,2,3,4,5,6],[4,5,6,7,8,9]]) 
print() # find the brr shape first 
brr.shape = # (4,3) ,resize it to  
print(brr) #How many rows and columns does it have now?

"""### Array Stacking & Splitting

"""

x1 = np.random.randint(10, size=(3, 3))
x2 = np.random.randint(10, size=(3,3))
print("x1: \n",x1)
print("x2: \n",x2)
print("Vertical Stack: \n",np.vstack((x1,x2))) #useful in pandas if you remember csv
print("Horizontal Stack: \n",np.hstack((x1,x2)))

# Generate 2x10 array
ss_arr_5 = np.random.randint(10, size=(2, 10))
print("ss_arr_5\n", ss_arr_5)
# Split into 5 arrays taking from both arrays in multidimensional array
np.hsplit(ss_arr_5, 5)
# Split after 2nd & 4th column
np.hsplit(ss_arr_5, (2, 4))

print("x1: \n",x1)
print("x2: \n",x2)
x3 = np.delete(x1,2,1)
x4 = np.delete(x2,1,0)
print("x3: \n",x3)
print("x4: \n",x4)

"""### Array Copying

"""

x1 = np.random.randint(10, size=(2, 2))
print("Initial x1:",x1)
x2 = x1 # they will point at same array
x2[0,0] = 2
print(x1,"\n",x2)

x2=x1.view() 
x2[1,1] = 2
print(x1,"\n",x2)

x2=x1.copy()
print(x1,"\n",x2)
#main difference between a copy and a view of an array is that the copy is a new array, and the view is just a view of the original array.

"""### Array Math
Basic mathematical functions operate elementwise on arrays, and are available both as operator overloads and as functions.
"""

x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)

# Elementwise sum; both produce the array
# [[ 6.0  8.0]
#  [10.0 12.0]]
print(x+2)
print(x + y)
print(np.add(x,2))
print(np.add(x, y))

# Elementwise difference; both produce the array
# [[-4.0 -4.0]
#  [-4.0 -4.0]]
print(x - y)
print(np.subtract(x, y))

# Elementwise product; both produce the array
# [[ 5.0 12.0]
#  [21.0 32.0]]
print(x * y)
print(np.multiply(x, y))

# Elementwise division; both produce the array
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print(x / y)
print(np.divide(x, y))
print(np.remainder(x, y))
print(np.log2(x))

# Elementwise square root; produces the array
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print(np.sqrt(x))

np.floor([1.2,3.23,123.21])

np.ceil([1.2,3.23,123.21])

x = np.random.randint(100, size=(4))
y = np.random.randint(100, size=(2,3))
print(y)
print("direct sum:",y.sum(axis=0))
print("cumsum : " ,y.cumsum(axis=0))
print("max:",y.max(axis=0))
print("min:",y.min(axis=0))

"""### Linear Algebra

"""

from numpy import linalg as LA
# Random 4 digit 1D array between 0 to 100
arr_5 = np.array([[1, 2], [3, 4]])
arr_6 = np.array([[2, 4], [6, 9]])

print("arr_5\n", arr_5)
print("arr_6\n", arr_6)
arr_8 = np.array([[5, 6], [7, 8]])

# Matrix multiplication with Dot Product
# (1 * 2) + (2 * 6) = 14 [0,0]
# (1 * 4) + (2 * 9) = 22 [0,1]
# (3 * 2) + (4 * 6) = 30 [1,0]
# (3 * 4) + (4 * 9) = 12 + 36 = 48 [1,1]
np.dot(arr_5, arr_6)
# Compute dot product of 2 or more arrays
LA.multi_dot([arr_5, arr_6, arr_8])

# Inner product 
# (1 * 2) + (2 * 4) = 10 [0,0]
# (1 * 6) + (2 * 9) = 24 [0,1]
# (3 * 2) + (4 * 4) = 22 [1,0]
# (3 * 6) + (4 * 9) = 54 [1,1]
np.inner(arr_5, arr_6)
np.dot(arr_5, arr_6)

# Tensor Dot Product
# (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) = 30
# (5 * 1) + (6 * 2) + (7 * 3) + (8 * 4) = 
arr_9 = np.array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
arr_10 = np.array([[1, 2],
       [3, 4]], dtype=object)
np.tensordot(arr_9, arr_10)

# Einstein Summation : Provides many ways to perform
# operations on multiple arrays
arr_11 = np.array([0, 1])
arr_12 = np.array([[0, 1, 2, 3], [4, 5, 6, 7]])
# Left Side of -> : 1 axis for arr_11 and 2 axis for arr_12
# Right of -> : Array we want (1D Array)
# ij : Means multiply arr_11 single item by each column of arr_12 and sum
# [0, 4 + 5 + 6 + 7]
np.einsum('i,ij->i', arr_11, arr_12)
# Sum values in arr_11
np.einsum('i->', arr_11)
# Dot Product
arr_3 = np.array([1, 2, 3, 4])
arr_4 = np.array([2, 4, 6, 8])
print("arr_3\n", arr_3)
print("arr_4\n", arr_4)
np.einsum('i,i->', arr_3, arr_4)
# Matrix multiplication
np.einsum('ij,jk', arr_5, arr_6)
# Get diagonal
np.einsum('ii', arr_5)
# Transpose
np.einsum('ji', arr_5)

# Raise matrix to the power of n
# Given [[a, b], [c, d]]
# [[a² + bc, ab +db], [ac + dc, d² + bc]
LA.matrix_power(arr_5, 2)

# Kronecker product of 2 arrays
# Given [[a, b], [c, d]], [[e, f], [g, h]]
# [[a*e, a*f, b*e, b*f], [a*g, a*h, b*g, b*h], ...]
np.kron(arr_5, arr_6)

# Compute eigenvalues
LA.eig(arr_5) # Returns eigenvectors
LA.eigvals(arr_5)

# Get Vector Norm sqrt(sum(x**2))
LA.norm(arr_5)

# Get Multiplicative Inverse of a matrix
LA.inv(arr_5)

# Get Condition number of matrix
LA.cond(arr_5)

# Determinates are used to compute volume, area, to solve systems
# of equations and more. It is a way you can multiply values in a
# matrix to get 1 number.
# For a matrix to have an inverse its determinate must not equal 0
# det([[a, b], [c, d]]) = a*d - b*c
arr_12 = np.array([[1, 2], [3, 4]])
# 1*4 - 2*3 = -2
LA.det(arr_12)

# Determinate of 3x3 Matrix
# det([[a, b, c], [d, e, f], [g, h, i]]) = a*e*i - b*d*i + c*d*h
# - a*f*h + b*f*g - c*e*g

# When we multiply a matrix times its inverse we get the identity
# matrix [[1,0],[0,1]] for a 2x2 matrix
# Calculate the inverse 1/(a*d - b*c) * [[d, -b], [-c, a]]
# 1/(4 - 6) = -.5 -> [[-.5*4, -.5*-2], [-.5*-3, -.5*a]]
arr_12_i = LA.inv(arr_12)
arr_12_i

np.dot(arr_12, arr_12_i)

# Solving Systems of Linear Equations
# If you have 3x + 5 = 9x -> 5 = 6x -> x = 5/6
# If you have x + 4y = 10 & 6x + 18y = 42
# Isolate x -> x = 10 - 4y
# 6(10 - 4y) + 18y = 42 -> 60 - 24y + 18y = 42 - > -6y = -18 -> y = 3
# x + 4*3 = 10 -> x = -2
arr_13 = np.array([[1, 4], [6, 18]])
arr_14 = np.array([10, 42])
# Solve will solve this for you as well
LA.solve(arr_13, arr_14)

# Return a identity matrix with defined number of rows and columns
np.eye(2, 2, dtype=int)

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# Inner product of vectors; both produce 219
print(v.dot(w))
print(np.dot(v, w))

# Matrix / vector product; both produce the rank 1 array [29 67]
print(x.dot(v))
print(np.dot(x, v))

# Matrix / matrix product; both produce the rank 2 array
# [[19 22]
#  [43 50]]
print(x.dot(y))
print(np.dot(x, y))

"""### Statistics Functions"""

x1 = np.arange(1,10)

#mean
print("Mean: ",np.mean(x1))

#median
print("Median:",np.median(x1))

#average
print("Average:",np.average(x1))

#standard deviation
print("Standard Deviation:",np.std(x1))

#variance
print("Variance:",np.var(x1))

"""### Trignometry Functions"""

x1 = np.linspace(-np.pi,np.pi,200)
plt.plot(x1,np.sin(x1))
np.arctan(1)
# ALso sinh ,cosh,tanh,arcsinh,arccosh etc
np.rad2deg(np.pi)
np.deg2rad(np.pi)
np.hypot(10,10)

"""### Comparison Functions"""

carr_1 = np.array([2, 3])
carr_2 = np.array([3, 2])
# Returns boolean based on whether arr_1 value Comparison arr_2 value
np.greater(carr_1, carr_2)
np.greater_equal(carr_1, carr_2)
np.less(carr_1, carr_2)
np.less_equal(carr_1, carr_2)
np.not_equal(carr_1, carr_2)
np.equal(carr_1, carr_2)

"""### Array Flags
Ndarray object has the following attributes. Its current values are returned
 by this function.
- C_CONTIGUOUS (C) -The data is in a single, C-style contiguous segment
- F_CONTIGUOUS (F) - The data is in a single, Fortran-style contiguous segment	
- OWNDATA (O) - The array owns the memory it uses or borrows it from another object	
- WRITEABLE (W) - The data area can be written to. Setting this to False locks the data, making it read-only
- ALIGNED (A) - The data and all elements are aligned appropriately for the hardware
- UPDATEIFCOPY (U) - This array is a copy of some other array. When this array is deallocated, the base array will be updated with the contents of this array
"""

arr = np.array([1,2,3,4,5]) 
print(arr.flags)

"""## Resources :


- Nicolas P. Rougier's Book "From Python to Numpy" ->
 [Link](https://www.labri.fr/perso/nrougier/from-python-to-numpy/) || [Link-2](https://github.com/rougier/numpy-tutorial)
- NumPy Official Documentation -> [Link](https://numpy.org/devdocs/user/absolute_beginners.html)
- Kaggle Has plethora of notebooks -> [Link](www.kaggle.com)
- Learning the python hardway -> [Link](https://learnpythonthehardway.org/book/)
- Free Code Camp's Videos -> [Link](https://www.youtube.com/watch?v=QUT1VHiLmmI)
- Edureka's video on Numpy -> [Link](https://www.youtube.com/watch?v=8JfDAm9y_7s) || [Link-2](https://www.edureka.co/blog/python-numpy-tutorial/)
- Derek Banas videos rock(the best) -> [Link](https://www.youtube.com/watch?v=8Y0qQEh7dJg) || [Link](https://github.com/derekbanas/NumPy-Tutorial/blob/master/NumPy%20Tut.ipynb)
- Numpy Playlist -> [Link](https://youtu.be/GB9ByFAIAH4?list=RDQMZI0VMokkS5U)
- Scipy Lectures -> [Link](https://scipy-lectures.org/)
- Machine Learning Plus -> [Link](https://www.machinelearningplus.com/python/numpy-tutorial-part1-array-python-examples/)
- DataQuest.io Tutorial -> [Link](https://www.dataquest.io/blog/numpy-tutorial-python/)
- Stanford's Lecture on Numpy-> [Link](https://cs231n.github.io/python-numpy-tutorial/#numpy)


"""

